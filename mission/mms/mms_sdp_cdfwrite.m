function [ outFileName ] = mms_sdp_cdfwrite( HeaderInfo, Dmgr )
% MMS_SDP_CDFWRITE writes the data to the corresponding CDF file.
%
%	filename_output = MMS_SDP_CDFWRITE( HeaderInfo, Dmgr)
%   will write an MMS CDF file containing the data stored to a temporary
%   output folder defined by ENVIR.DROPBOX_ROOT. HeaderInfo contains start
%   time as well as information about source files ("Parents"). Dmgr is a
%   handle for data read into mms_sdp_dmgr.
%
%   Example:
%   filename_output = mms_sdp_cdfwrite(HeaderInfo, Dmgr);
%
%	Note 1: It is assumed that other SDC processing scripts will move the
%   created output file to its final destination (from /ENIVR.DROPBOX_ROOT/
%   to /path/as/defined/by/	SDC Developer Guide, v1.7).
%
% 	See also MMS_SDC_SDP_PROC, MMS_SDP_DMGR, MMS_SDC_SDP_INIT.

% Verify that we have all the information that is required.
narginchk(2,2);

global ENVIR; %#ok<GVMIS>
MMS_CONST = Dmgr.CONST;

INST_NAME = 'edp'; % Electric double probe
DCE_FILE = 'dce2d';
EFIELD_MAX  = mms_sdp_typecast('dce', 700); % Max value of E-field in mV/m with shortening factor applied
VOLTAGE_MIN = mms_sdp_typecast('dce', -120); % Min voltage
VOLTAGE_MAX = mms_sdp_typecast('dce', 50); % Max voltage
QUALITY_MAX = mms_sdp_typecast('quality', 4);  % Max value of quality.
COMPRESS_LEVEL = 'gzip.6'; % Default compression level to be used for variables.

procId = Dmgr.procId;
if procId==MMS_CONST.Error
  errStr = 'mms_sdp_dmgr not properly initialized';
  irf.log('critical',errStr), error(errStr)
end
procName = MMS_CONST.SDCProcs{procId};
scId = Dmgr.scId;
tmMode = Dmgr.tmMode;
tmModeStr = MMS_CONST.TmModes{tmMode};
datasetPrefix = sprintf('mms%i_%s',scId,INST_NAME);


% NOTE MOVE TO DROPBOX FOLDER BEFORE TRYING TO WRITE ANYTHING AS
% CDF MAY TRY TO WRITE TEMPORARY FILES IN THE CURRENT WORKING
% DIRECTORY WHEN EXECUTING.
oldDir = pwd; cd(ENVIR.DROPBOX_ROOT);
[outFileName, verFileName] = get_file_name();
irf.log('notice',['Prepairing to write file to DROPBOX_ROOT/',outFileName,'.cdf']);

GATTRIB = getGlobalAttributes;
VATTRIB = getVariableAttributes;
% Update some dynamic GlobalAttributes common to all data products.
if(HeaderInfo.numberOfSources==1)
  GATTRIB.Parents = {['CDF>',HeaderInfo.parents_1]}; % Add the only parent
elseif(HeaderInfo.numberOfSources>=2)
  GATTRIB.Parents = {['CDF>',HeaderInfo.parents_1]}; % Add first parent
  for i=2:HeaderInfo.numberOfSources % Add each extra parent source
    GATTRIB.Parents = [GATTRIB.Parents; {['CDF>',...
      HeaderInfo.(sprintf('parents_%i',i))]}];
  end
end
try
  % Add also timeline xml files used to bitmask maneuvers during.
  for iXml = 1:size(Dmgr.timelineXML, 1)
    GATTRIB.Parents = [GATTRIB.Parents; ...
      {['XML>', Dmgr.timelineXML(iXml, 1:end-4)]}];
  end
catch
  irf.log('notice', 'Failed to add xml timeline(-s) to GATTRIB parents.');
end
GATTRIB.Logical_file_id = {outFileName};    % Filename, except '.cdf'
GATTRIB.Data_version = {['v' verFileName]}; % 'vX.Y.Z'

switch procId
  case MMS_CONST.SDCProc.ql
    %% QL DCE2D - get data
    % QL outputs: DCE_dsl [E_x, E_y, E_z], Bitmask and Quality.
    % (and corresponding epoch and labels)
    dataType = [tmModeStr '_' procName '_' DCE_FILE];
    dataDesc = sprintf(...
      'MMS %i dual probe %s (%s), two dimensional electric field.',...
      scId,procName,tmModeStr);
    
    dce_xyz_dsl = Dmgr.dce_xyz_dsl;
    if mms_is_error(dce_xyz_dsl)
      errStr='Cannot output ''dce_xyz_dsl''';
      irf.log('critical', errStr); error('MATLAB:MMS_SDP_CDFWRITE:OUT', errStr);
    end
    
    epochTT = dce_xyz_dsl.time;
    % Ensure dce is in correct class
    dsl = mms_sdp_typecast('dce', dce_xyz_dsl.data);
    % Same for bitmask
    bitmask = mms_sdp_typecast('bitmask', dce_xyz_dsl.bitmask);
    % and quality
    quality = mms_sdp_typecast('quality',mms_sdp_bitmask2quality('e',dce_xyz_dsl.bitmask));
    dplus   = mms_sdp_typecast('deltaplus', 10^9/(2*Dmgr.samplerate)); % in nanoseconds, half the time interval.
    repres1 = ['x'; 'y'; 'z'];
    
    name.epoch   = [datasetPrefix '_dce_epoch'];
    name.dsl     = [datasetPrefix '_dce_xyz_dsl'];
    name.bitmask = [datasetPrefix '_dce_bitmask'];
    name.label   = 'LABL_1';
    name.quality = [datasetPrefix '_dce_quality'];
    name.dplus   = [datasetPrefix '_deltap']; % Delta Plus (time interval)
    name.repres1 = [datasetPrefix '_representation1'];
    
    label = ['Ex DSL'; 'Ey DSL'; 'Ez DSL'];
    outVars = {name.epoch, epochTT, name.label, label, name.dsl, dsl, ...
      name.bitmask, bitmask, name.quality, quality, ...
      name.dplus, dplus, name.repres1, repres1};
    % RecordBound, ie individual cdf records for each row.
    recBound = {name.epoch, name.dsl, name.bitmask, name.quality};
    %Variable Datatypes
    varDatatype = {name.epoch, getfield(mms_sdp_typecast('epoch'),'cdf'), ...
      name.label,   getfield(mms_sdp_typecast('label'),'cdf'), ...
      name.dsl,     getfield(mms_sdp_typecast('dce'),'cdf'), ...
      name.bitmask, getfield(mms_sdp_typecast('bitmask'),'cdf'),...
      name.quality, getfield(mms_sdp_typecast('quality'),'cdf'), ...
      name.dplus,   getfield(mms_sdp_typecast('deltaplus'),'cdf'), ...
      name.repres1, getfield(mms_sdp_typecast('label'),'cdf')};
    % Compression level for each variable. Note: Not for TT2000 epoch.
    compressVars = {name.label, COMPRESS_LEVEL, name.dsl, COMPRESS_LEVEL, ...
      name.bitmask, COMPRESS_LEVEL, name.quality, COMPRESS_LEVEL, ...
      name.dplus, COMPRESS_LEVEL, name.repres1, COMPRESS_LEVEL};
    
    %% Update VariableAttributes
    VATTRIB.CATDESC = {name.epoch, 'Time tags, in TT2000'; ...
      name.label,   'Label'; ...
      name.dsl,     'DC E field in DSL frame of reference';...
      name.bitmask, 'Status bitmask';...
      name.quality, 'Quality indicator (3 good), (2 ok data, use with some caution), (1 bad data, use with caution), (0 Really bad data or no data at all)';...
      name.dplus,   'Delta plus/minus, time interval during which the data was measured'; ...
      name.repres1, 'Representation'};
    VATTRIB.COORDINATE_SYSTEM = {name.dsl, 'DSL'};
    VATTRIB.DELTA_PLUS_VAR = {name.epoch, name.dplus};
    VATTRIB.DELTA_MINUS_VAR = {name.epoch, name.dplus};
    VATTRIB.DEPEND_0 = {name.dsl,     name.epoch; ...
      name.bitmask, name.epoch;...
      name.quality, name.epoch};
    VATTRIB.DISPLAY_TYPE = {name.dsl,     'time_series'};
    VATTRIB.FIELDNAM = {name.epoch, 'Time tags'; ...
      name.label,   'Label'; ...
      name.dsl,     'DC E field (dsl)';...
      name.bitmask, 'Status bitmask';...
      name.quality, 'Quality indicator';...
      name.dplus,   'Delta plus/minus';...
      name.repres1, 'Representation'};
    VATTRIB.FILLVAL = {name.epoch, getfield(mms_sdp_typecast('epoch'),'fillval'); ...
      name.dsl,     getfield(mms_sdp_typecast('dce'),'fillval');...
      name.bitmask, getfield(mms_sdp_typecast('bitmask'),'fillval');...
      name.quality, getfield(mms_sdp_typecast('quality'),'fillval'); ...
      name.dplus,   getfield(mms_sdp_typecast('deltaplus'), 'fillval')};
    VATTRIB.FORMAT = {name.label,   'A23'; ...
      name.dsl,     'F8.3';...
      name.bitmask, 'I7';...
      name.quality, 'I7'; ...
      name.dplus,   'I19'; ...
      name.repres1, 'A23'};
    VATTRIB.LABL_PTR_1 = {name.dsl, name.label};
    VATTRIB.REPRESENTATION_1 = {name.dsl, name.repres1};
    VATTRIB.SI_CONVERSION = {name.dsl,     '1.0e-3>V m^-1'; ...
      name.bitmask, ' > '; ...
      name.quality, ' > '; ...
      name.dplus,   '1.0e-9>s'};
    VATTRIB.TENSOR_ORDER = {name.dsl, mms_sdp_typecast('tensor_order',1);...
      name.bitmask, mms_sdp_typecast('tensor_order',0);...
      name.quality, mms_sdp_typecast('tensor_order',0)};
    VATTRIB.TIME_BASE = {name.epoch, 'J2000'};
    VATTRIB.UNITS = {name.epoch, 'ns'; ...
      name.dsl,     'mV/m'; ...
      name.bitmask, ' ';...
      name.quality, ' ';...
      name.dplus,   'ns'};
    VATTRIB.VALIDMIN = {name.epoch, spdfcomputett2000([1990,01,01,0,0,0,0,0,0]); ...
      name.dsl,     -EFIELD_MAX;...
      name.bitmask, mms_sdp_typecast('bitmask',0);...
      name.quality, mms_sdp_typecast('quality',0); ...
      name.dplus,   mms_sdp_typecast('deltaplus', 30517)}; % floor(10^9/(2*16384)), highest brst rounded down;
    VATTRIB.VALIDMAX = {name.epoch, spdfcomputett2000([2100,01,01,0,0,0,0,0,0]); ...
      name.dsl,     EFIELD_MAX;...
      name.bitmask, mms_sdp_typecast('bitmask',65534);...
      name.quality, QUALITY_MAX; ...
      name.dplus,   mms_sdp_typecast('deltaplus',62500000)};  % int64(10^9/(2*8)), lowest comm
    VATTRIB.VAR_TYPE = {name.epoch, 'support_data'; ...
      name.label,   'metadata'; ...
      name.dsl,     'data';...
      name.bitmask, 'support_data';...
      name.quality, 'support_data'; ...
      name.dplus,   'support_data';...
      name.repres1, 'metadata'};
    VATTRIB.MONOTON = {name.epoch, 'INCREASE'};
    
  case MMS_CONST.SDCProc.l2a
    % L2A (same as old L2pre)
    varNameSuffix = [tmModeStr, '_l2a'];
    dataType = [tmModeStr '_' procName '_' DCE_FILE];
    dataDesc = sprintf(...
      'MMS %i dual probe %s (%s), two dimensional electric field. L2A file',...
      scId,procName,tmModeStr);
    
    % Verify output data exist. L2A outputs: DCE [e12, e34, e56], phase,
    % Spinfit [e12, e34] {sdev A B C}, bitmask of DCE [e12, e34, e56] and a
    % quality. (and corresponding epoch and labels).
    dce = Dmgr.dce;
    if mms_is_error(dce)
      errStr='Cannot output ''dce''';
      irf.log('critical', errStr); error('MATLAB:MMS_SDP_CDFWRITE:OUT', errStr);
    end
    phase = Dmgr.phase;
    if mms_is_error(phase)
      errStr='Cannot output ''phase''';
      irf.log('critical', errStr); error('MATLAB:MMS_SDP_CDFWRITE:OUT', errStr);
    end
    radius = Dmgr.orb_radius;
    if mms_is_error(radius)
      errStr='Cannot output ''orb_radius''';
      irf.log('critical', errStr); error('MATLAB:MMS_SDP_CDFWRITE:OUT', errStr);
    end
    spinfit = Dmgr.spinfits;
    if mms_is_error(spinfit)
      errStr='Cannot output ''spinfits''';
      irf.log('critical', errStr); error('MATLAB:MMS_SDP_CDFWRITE:OUT', errStr);
    end
    adc_off = Dmgr.adc_off;
    if mms_is_error(adc_off)
      errStr='Cannot output ''adc_off''';
      irf.log('critical', errStr); error('MATLAB:MMS_SDP_CDFWRITE:OUT', errStr);
    end
    delta_off = Dmgr.delta_off;
    if mms_is_error(delta_off)
      errStr='Cannot output ''delta_off''';
      irf.log('critical', errStr); error('MATLAB:MMS_SDP_CDFWRITE:OUT', errStr);
    end
    sdpPair = fields(spinfit.sfit); % Defailt e12 & e34
    % NEW CMDModel, writing here to be used by Brst segments. As of 2016/09/22
    % it is nominally only produced for MMS4 for time after probe 4 failed. Ie.
    % if it does not exist, do not fail and do not try to write it to file.
    cmdmodel = Dmgr.CMDModel;
    if mms_is_error(cmdmodel) || isempty(cmdmodel)
      no_CMD = true;
    else
      no_CMD = false;
    end
    sw_wake = Dmgr.sw_wake;
    if mms_is_error(sw_wake)
      errStr = 'Cannot output ''sw_wake''';
      irf.log('critical', errStr); error('MATLAB:MMS_SDP_CDFWRITE:OUT', errStr);
    end
    
    epochTT = dce.time;
    % adcdata & dcedata, defined as CDF_REAL4 (single in Matlab)
    % NOTE: The minus sign on DCE E56 in order to flip it to the DSL Z direction!
    dcedata = mms_sdp_typecast('dce',[dce.e12.data, dce.e34.data, -dce.e56.data]);
    adcdata = mms_sdp_typecast('adc_offset',[adc_off.(sdpPair{1}), adc_off.(sdpPair{2})]);
    phasedata = mms_sdp_typecast('phase',phase.data);
    % FIXME: Should not use irf.nanmean when writing all delta offset records.
    deltadata = mms_sdp_typecast('delta_offset', irf.nanmean([real(delta_off), imag(delta_off)]));
    sw_wake = mms_sdp_typecast('dce', sw_wake);
    radius = mms_sdp_typecast('dce', radius);
    % Bitmask, defined as CDF_UINT1 (uint8 in Matlab)
    bitmask = mms_sdp_typecast('bitmask',[dce.e12.bitmask, dce.e34.bitmask, dce.e56.bitmask]);
    quality = mms_sdp_typecast('quality',mms_sdp_bitmask2quality('e',bitmask(:,1)));
    dplus   = mms_sdp_typecast('deltaplus', 10^9/(2*Dmgr.samplerate)); % in nanoseconds, half the time interval.
    dplus2  = mms_sdp_typecast('deltaplus', double(MMS_CONST.Limit.SPINFIT_INTERV)/2); % in nanoseconds, half the time interval.
    
    name.epoch   = [datasetPrefix '_epoch_' varNameSuffix];
    name.dce     = [datasetPrefix '_dce_' varNameSuffix];
    name.phase   = [datasetPrefix '_phase_' varNameSuffix];
    name.bitmask = [datasetPrefix '_bitmask_' varNameSuffix];
    name.quality = [datasetPrefix '_quality_' varNameSuffix];
    name.sfitsEpoch = [datasetPrefix '_epoch_spinfit_' varNameSuffix];
    name.adc     = [datasetPrefix '_adc_offset_' varNameSuffix];
    name.delta   = [datasetPrefix '_delta_offset_' varNameSuffix];
    name.swwake  = [datasetPrefix '_sw_wake_' varNameSuffix];
    name.radius  = [datasetPrefix '_orb_radius_' varNameSuffix];
    name.label   = [datasetPrefix '_label1_' varNameSuffix]; % DCE data
    name.label2  = [datasetPrefix '_label2_' varNameSuffix]; % Spinfit coeff. (B&C and up) specified further down.
    name.label3  = [datasetPrefix '_label3_' varNameSuffix]; % ADC offsets
    name.label4  = [datasetPrefix '_label4_' varNameSuffix]; % Delta offsets
    name.dplus   = [datasetPrefix '_deltap_' varNameSuffix]; % Delta Plus (time interval)
    name.dplus2  = [datasetPrefix '_deltap2_' varNameSuffix]; % Delta Plus (time interval for spinfits)
    name.repres1 = [datasetPrefix '_representation1_' varNameSuffix];
    name.repres2 = [datasetPrefix '_representation2_' varNameSuffix];
    repres1      = ['x'; 'y'; 'z'];
    repres2      = ['x'; 'y'];
    label        = ['E_12'; 'E_34'; 'E_56'];
    label3       = ['E_12'; 'E_34'];
    label4       = ['Delta Ex DSL'; 'Delta Ey DSL'];
    
    outVars = {name.epoch, epochTT, name.label, label, name.dce, dcedata, ...
      name.bitmask, bitmask, name.quality, quality, name.phase, phasedata, ...
      name.label3, label3, name.adc, adcdata, ...
      name.sfitsEpoch, spinfit.time, name.label4, label4, ...
      name.delta, deltadata, ...
      name.swwake, sw_wake, ...
      name.radius, radius, ...
      name.dplus, dplus, name.dplus2, dplus2, ...
      name.repres1, repres1, name.repres2, repres2};
    % RecordBound, ie individual cdf records for each row.
    recBound = {name.epoch, name.dce, name.phase, name.bitmask, ...
      name.quality, name.adc, name.sfitsEpoch, name.swwake, name.radius};
    % FIXME: When all delta_offset values inclunde also delta in recBound
    % recBound = {name.epoch, name.dce, name.phase, name.bitmask, ...
    %  name.quality, name.adc, name.sfitsEpoch, name.delta};
    %Variable Datatypes
    varDatatype = {name.epoch, getfield(mms_sdp_typecast('epoch'),'cdf'), ...
      name.label,      getfield(mms_sdp_typecast('label'),     'cdf'), ...
      name.label2,     getfield(mms_sdp_typecast('label'),     'cdf'), ...
      name.label3,     getfield(mms_sdp_typecast('label'),     'cdf'), ...
      name.label4,     getfield(mms_sdp_typecast('label'),     'cdf'), ...
      name.dce,        getfield(mms_sdp_typecast('dce'),       'cdf'), ...
      name.phase,      getfield(mms_sdp_typecast('phase'),     'cdf'), ...
      name.bitmask,    getfield(mms_sdp_typecast('bitmask'),   'cdf'), ...
      name.quality,    getfield(mms_sdp_typecast('quality'),   'cdf'), ...
      name.adc,        getfield(mms_sdp_typecast('adc_offset'),'cdf'), ...
      name.sfitsEpoch, getfield(mms_sdp_typecast('epoch'),     'cdf'), ...
      name.delta,      getfield(mms_sdp_typecast('delta_offset'),'cdf'), ...
      name.swwake,     getfield(mms_sdp_typecast('dce'),        'cdf'), ...
      name.radius,     getfield(mms_sdp_typecast('dce'),        'cdf'), ...
      name.dplus,      getfield(mms_sdp_typecast('deltaplus'),  'cdf'), ...
      name.dplus2,     getfield(mms_sdp_typecast('deltaplus'),  'cdf'), ...
      name.repres1,    getfield(mms_sdp_typecast('label'),'cdf'), ...
      name.repres2,    getfield(mms_sdp_typecast('label'),'cdf')};
    % Compression level for each variable. Note: Not for TT2000 epoch.
    compressVars = {name.dce, COMPRESS_LEVEL,...
      name.phase, COMPRESS_LEVEL, name.bitmask, COMPRESS_LEVEL, ...
      name.quality, COMPRESS_LEVEL, name.adc, COMPRESS_LEVEL, ...
      name.delta, COMPRESS_LEVEL, name.label, COMPRESS_LEVEL, ...
      name.label2, COMPRESS_LEVEL, name.label3, COMPRESS_LEVEL, ...
      name.label4, COMPRESS_LEVEL, name.dplus, COMPRESS_LEVEL, ...
      name.dplus2, COMPRESS_LEVEL, name.swwake, COMPRESS_LEVEL, ...
      name.repres1, COMPRESS_LEVEL, name.repres2, COMPRESS_LEVEL, ...
      name.radius, COMPRESS_LEVEL};
    
    %% Update VariableAttributes
    VATTRIB.CATDESC = {name.epoch, 'Time tags, in TT2000'; ...
      name.label,      'Label'; ...
      name.label2,     'Label';...
      name.label3,     'Label';...
      name.label4,     'Label'; ...
      name.dce,        'DC E field [E12, E34, E56] (BCS)'; ...
      name.phase,      'Spacecraft phase calculated from DEFATT (0 deg when SC X closest to sunward direction)';...
      name.bitmask,    'Status bitmask';...
      name.quality,    'Quality indicator (3 good), (2 ok data, use with some caution), (1 bad data, use with caution), (0 Really bad data or no data at all)';...
      name.sfitsEpoch, 'Time tags, in TT2000'; ...
      name.adc,        'ADC offsets to be removed from DC E';...
      name.delta,      'Delta offset between probe pair E12 & E34.';...
      name.swwake,     'Solar wind wake removed from data measurements.'; ...
      name.radius,     'Spacecraft orbital radius'; ...
      name.dplus,      'Delta plus/minus, time interval during which the data was measured'; ...
      name.dplus2,     'Delta plus/minus, time interval during which the data was measured'; ...
      name.repres1,    'Representation'; ...
      name.repres2,    'Representation'};
    VATTRIB.COORDINATE_SYSTEM = {name.dce, 'BCS'; ...
      name.delta,       'DSL'};
    VATTRIB.DELTA_PLUS_VAR = {name.epoch, name.dplus; ...
      name.sfitsEpoch, name.dplus2};
    VATTRIB.DELTA_MINUS_VAR = {name.epoch, name.dplus; ...
      name.sfitsEpoch, name.dplus2};
    VATTRIB.DEPEND_0 = {name.dce, name.epoch; ...
      name.phase,   name.epoch; ...
      name.bitmask, name.epoch;...
      name.quality, name.epoch;...
      name.adc,     name.epoch; ...
      name.swwake,  name.epoch; ...
      name.radius,  name.epoch};
    % FIXME: When all delta_offset values inclunde also delta in recBound
    % VATTRIB.DEPEND_0 = {name.dce, name.epoch; ...
    %  name.phase,   name.epoch; ...
    %  name.bitmask, name.epoch;...
    %  name.quality, name.epoch;...
    %  name.adc,     name.epoch;...
    %  name.delta,   name.sfitsEpoch};
    VATTRIB.DISPLAY_TYPE = {name.dce,     'time_series'};
    VATTRIB.FIELDNAM = {name.epoch, 'Time tags'; ...
      name.label,      'Label'; ...
      name.label2,     'Label';...
      name.label3,     'Label';...
      name.label4,     'Label';...
      name.dce,        'DC E field (BCS)'; ...
      name.phase,      'Phase (SC X = 0 deg)';...
      name.bitmask,    'Status bitmask'; ...
      name.quality,    'Quality indicator';...
      name.sfitsEpoch, 'Time tags spin fit'; ...
      name.adc,        'ADC offset';...
      name.delta,      'Delta offset';...
      name.swwake,     'SW wake subtracted'; ...
      name.radius,     'SC orbital radius'; ...
      name.dplus,      'Delta plus/minus';...
      name.dplus2,     'Delta plus/minus';...
      name.repres1,    'Representation'; ...
      name.repres2,    'Representation'};
    VATTRIB.FILLVAL = {name.epoch, getfield(mms_sdp_typecast('epoch'),'fillval'); ...
      name.dce,        getfield(mms_sdp_typecast('dce'),       'fillval');...
      name.phase,      getfield(mms_sdp_typecast('phase'),     'fillval');...
      name.bitmask,    getfield(mms_sdp_typecast('bitmask'),   'fillval');...
      name.quality,    getfield(mms_sdp_typecast('quality'),   'fillval');...
      name.sfitsEpoch, getfield(mms_sdp_typecast('epoch'),     'fillval');...
      name.adc,        getfield(mms_sdp_typecast('adc_offset'),'fillval');...
      name.swwake,     getfield(mms_sdp_typecast('dce'),       'fillval');...
      name.radius,     getfield(mms_sdp_typecast('dce'),       'fillval');...
      name.delta,      getfield(mms_sdp_typecast('delta_offset'),'fillval'); ...
      name.dplus,      getfield(mms_sdp_typecast('deltaplus'), 'fillval'); ...
      name.dplus2,     getfield(mms_sdp_typecast('deltaplus'), 'fillval')};
    VATTRIB.FORMAT = {name.label,   'A23'; ...
      name.label2,  'A23';...
      name.label3,  'A23';...
      name.label4,  'A23';...
      name.dce,     'F8.3';...
      name.phase,   'F8.3';...
      name.bitmask, 'I7';...
      name.quality, 'I7';...
      name.adc,     'F8.3';...
      name.delta,   'F8.3'; ...
      name.swwake,  'F8.3'; ...
      name.radius,  'F8.3'; ...
      name.dplus,   'I19'; ...
      name.dplus2,  'I19'; ...
      name.repres1, 'A23'; ...
      name.repres2, 'A23'};
    VATTRIB.LABL_PTR_1 = {name.dce, name.label; name.bitmask, name.label; ...
      name.adc, name.label3; name.delta, name.label4; name.swwake, name.label3};
    VATTRIB.REPRESENTATION_1 = {name.dce, name.repres1; ...
      name.delta, name.repres2};
    VATTRIB.SI_CONVERSION = {name.dce,     '1.0e-3>V m^-1';...
      name.phase,   '0.0174532925>rad';...
      name.bitmask, ' > ';...
      name.quality, ' > ';...
      name.adc,     '1.0e-3>V m^-1';...
      name.delta,   '1.0e-3>V m^-1'; ...
      name.swwake,  '1.0e-3>V m^-1'; ...
      name.radius,  '1.0e3>m'; ...
      name.dplus,   '1.0e-9>s';...
      name.dplus2,  '1.0e-9>s'};
    VATTRIB.TIME_BASE = {name.epoch, 'J2000'; ...
      name.sfitsEpoch, 'J2000'};
    VATTRIB.TENSOR_ORDER = {name.dce, mms_sdp_typecast('tensor_order',1);...
      name.phase,   mms_sdp_typecast('tensor_order',0);...
      name.adc,     mms_sdp_typecast('tensor_order',0);...
      name.quality, mms_sdp_typecast('tensor_order',0);...
      name.bitmask, mms_sdp_typecast('tensor_order',0);...
      name.delta,   mms_sdp_typecast('tensor_order',1);...
      name.swwake,  mms_sdp_typecast('tensor_order',1)};
    VATTRIB.UNITS = {name.epoch, 'ns'; ...
      name.sfitsEpoch, 'ns';...
      name.dce,     'mV/m';...
      name.phase,   'deg';...
      name.bitmask, ' ';...
      name.quality, ' ';...
      name.adc,     'mV/m';...
      name.delta,   'mV/m';...
      name.swwake,  'mV/m';...
      name.radius,  'km'; ...
      name.dplus,   'ns';...
      name.dplus2,  'ns'};
    VATTRIB.VALIDMIN = {name.epoch, spdfcomputett2000([1990,01,01,0,0,0,0,0,0]); ...
      name.dce,     -EFIELD_MAX;...
      name.phase,   mms_sdp_typecast('phase',0);...
      name.bitmask, mms_sdp_typecast('bitmask',0);...
      name.quality, mms_sdp_typecast('quality',0);...
      name.adc,     -EFIELD_MAX;...
      name.sfitsEpoch, spdfcomputett2000([1990,01,01,0,0,0,0,0,0]);...
      name.delta,   -EFIELD_MAX; ...
      name.swwake,  -EFIELD_MAX; ...
      name.radius,  mms_sdp_typecast('dce', 0); ... % 0 km
      name.dplus,   mms_sdp_typecast('deltaplus',61000); ... % int64(10^9/(2*8192)), highest brst rounded down
      name.dplus2,  mms_sdp_typecast('deltaplus',0)};
    VATTRIB.VALIDMAX = {name.epoch, spdfcomputett2000([2100,01,01,0,0,0,0,0,0]); ...
      name.dce,        EFIELD_MAX;...
      name.phase,      mms_sdp_typecast('phase',360);...
      name.bitmask,    mms_sdp_typecast('bitmask',65534);...
      name.quality,    QUALITY_MAX;...
      name.adc,        EFIELD_MAX;...
      name.sfitsEpoch, spdfcomputett2000([2100,01,01,0,0,0,0,0,0]);...
      name.delta,      EFIELD_MAX; ...
      name.swwake,     EFIELD_MAX; ...
      name.radius,     mms_sdp_typecast('dce', 637120); ... % approx 100*R_Earth in km
      name.dplus,      mms_sdp_typecast('deltaplus',62500000); ... % int64(10^9/(2*8)), lowest comm
      name.dplus2,     mms_sdp_typecast('deltaplus',1000000000000)}; ... % 100 spins at nominal spinrate..
      VATTRIB.VAR_TYPE = {name.epoch, 'support_data'; ...
      name.label,      'metadata'; ...
      name.label2,     'metadata';...
      name.label3,     'metadata';...
      name.label4,     'metadata';...
      name.dce,        'data';...
      name.phase,      'support_data';...
      name.bitmask,    'support_data';...
      name.quality,    'support_data';...
      name.sfitsEpoch, 'support_data'; ...
      name.adc,        'support_data';...
      name.delta,      'support_data'; ...
      name.swwake,     'support_data'; ...
      name.radius,     'support_data'; ...
      name.dplus,      'support_data';...
      name.dplus2,     'support_data';...
      name.repres1,    'metadata'; ...
      name.repres2,    'metadata'};
    VATTRIB.MONOTON = {name.epoch, 'INCREASE';...
      name.sfitsEpoch, 'INCREASE'};
    
    switch (size(spinfit.sfit.(sdpPair{1}),2))
      case 3
        % [A], B & C, 15 char each.
        label2 = ['Ex DSL'; 'Ey DSL'];
      case 5
        % [A], B, C, D & E, 16 char each.
        label2 = ['Fit y=B*cos(wt) '; 'Fit y=C*sin(wt) '; ...
          'Fit y=D*cos(2wt)'; 'Fit y=E*sin(2wt)'];
      case 7
        % [A], B, C, D, E, F & G, 16 char each.
        label2 = ['Fit y=B*cos(wt) '; 'Fit y=C*sin(wt) '; ...
          'Fit y=D*cos(2wt)'; 'Fit y=E*sin(2wt)';...
          'Fit y=F*cos(3wt)'; 'Fit y=G*sin(3wt)'];
      otherwise
        errStr = 'Number of terms in spinfit incorrect, must be 3, 5 or 7.';
        irf.log('critical', errStr);
        error('MATLAB:MMS_SDP_CDFWRITE:OUT', errStr);
    end
    outVars = [outVars {name.label2, label2}];
    
    for iPair=1:numel(sdpPair)
      name.sfits.(sdpPair{iPair}) = [datasetPrefix,'_espin_', strrep(sdpPair{iPair},'e','p'),'_', varNameSuffix];
      name.sfitSdev = [datasetPrefix '_sdevfit_', strrep(sdpPair{iPair},'e','p'),'_', varNameSuffix]; % Spinfit SDEV.
      name.sfitAfit = [datasetPrefix '_offsfit_', strrep(sdpPair{iPair},'e','p'),'_', varNameSuffix]; % Spinfit A coeff.
      % Update output variables
      outVars = [outVars {...
        name.sfits.(sdpPair{iPair}), spinfit.sfit.(sdpPair{iPair})(:,2:end), ...
        name.sfitSdev, mms_sdp_typecast('spinfits',spinfit.sdev.(sdpPair{iPair})), ...
        name.sfitAfit, mms_sdp_typecast('spinfits',spinfit.sfit.(sdpPair{iPair})(:,1))}]; %#ok<AGROW>
      recBound = [recBound {name.sfits.(sdpPair{iPair}), ...
        name.sfitSdev, name.sfitAfit}]; %#ok<AGROW>
      varDatatype = [varDatatype {...
        name.sfits.(sdpPair{iPair}), getfield(mms_sdp_typecast('spinfits'),'cdf'), ...
        name.sfitSdev,   getfield(mms_sdp_typecast('spinfits'), 'cdf'), ...
        name.sfitAfit,   getfield(mms_sdp_typecast('spinfits'), 'cdf')}]; %#ok<AGROW>
      compressVars = [compressVars {...
        name.sfits.(sdpPair{iPair}), COMPRESS_LEVEL, ...
        name.sfitSdev, COMPRESS_LEVEL, ...
        name.sfitAfit, COMPRESS_LEVEL}]; %#ok<AGROW>
      % Update VATTRIB
      VATTRIB.CATDESC = [VATTRIB.CATDESC; {...
        name.sfits.(sdpPair{iPair}), ['Spinfit: coeffs B=Ex,C=Ey and up of y=A+B*cos(wt)+C*sin(wt)+... ', sdpPair{iPair}]; ...
        name.sfitSdev, ['Standard deviation of spinfits ', sdpPair{iPair}]; ...
        name.sfitAfit, ['A coeff. (dc level) of spinfits ', sdpPair{iPair}]}];
      VATTRIB.COORDINATE_SYSTEM = [VATTRIB.COORDINATE_SYSTEM; ...
        {name.sfits.(sdpPair{iPair}), 'DSL'}];
      VATTRIB.DEPEND_0 = [VATTRIB.DEPEND_0; {...
        name.sfits.(sdpPair{iPair}), name.sfitsEpoch; ...
        name.sfitSdev, name.sfitsEpoch; ...
        name.sfitAfit, name.sfitsEpoch}];
      VATTRIB.DISPLAY_TYPE = [VATTRIB.DISPLAY_TYPE; {...
        name.sfits.(sdpPair{iPair}), 'time_series'}];
      VATTRIB.FIELDNAM = [VATTRIB.FIELDNAM; {...
        name.sfits.(sdpPair{iPair}), ['DC E field from spin fit of ', sdpPair{iPair}, ' (DSL)']; ...
        name.sfitSdev, ['Sdev spinfits ', sdpPair{iPair}]; ...
        name.sfitAfit, ['A coeff. spinfits ', sdpPair{iPair}]}];
      VATTRIB.FILLVAL = [VATTRIB.FILLVAL; {...
        name.sfits.(sdpPair{iPair}), getfield(mms_sdp_typecast('spinfits'),'fillval'); ...
        name.sfitSdev,   getfield(mms_sdp_typecast('spinfits'),  'fillval');...
        name.sfitAfit,   getfield(mms_sdp_typecast('spinfits'),  'fillval')}];
      VATTRIB.FORMAT = [VATTRIB.FORMAT; {...
        name.sfits.(sdpPair{iPair}), 'F8.3'; ...
        name.sfitSdev, 'F8.3'; ...
        name.sfitAfit, 'F8.3'}];
      VATTRIB.LABL_PTR_1 = [VATTRIB.LABL_PTR_1; {...
        name.sfits.(sdpPair{iPair}), name.label2}];
      VATTRIB.SI_CONVERSION = [VATTRIB.SI_CONVERSION; {...
        name.sfits.(sdpPair{iPair}), '1.0e-3>V m^-1'; ...
        name.sfitSdev, '1.0e-3>V m^-1'; ...
        name.sfitAfit, '1.0e-3>V m^-1'}];
      VATTRIB.TENSOR_ORDER = [VATTRIB.TENSOR_ORDER; {...
        name.sfits.(sdpPair{iPair}), mms_sdp_typecast('tensor_order',1);...
        name.sfitSdev, mms_sdp_typecast('tensor_order',0);...
        name.sfitAfit, mms_sdp_typecast('tensor_order',0)}];
      VATTRIB.UNITS = [VATTRIB.UNITS; {...
        name.sfits.(sdpPair{iPair}), 'mV/m';...
        name.sfitSdev, 'mV/m';...
        name.sfitAfit, 'mV/m'}];
      VATTRIB.VALIDMIN = [VATTRIB.VALIDMIN; {...
        name.sfits.(sdpPair{iPair}), -EFIELD_MAX; ...
        name.sfitSdev, -EFIELD_MAX; ...
        name.sfitAfit, -EFIELD_MAX}];
      VATTRIB.VALIDMAX = [VATTRIB.VALIDMAX; {...
        name.sfits.(sdpPair{iPair}), EFIELD_MAX; ...
        name.sfitSdev,   EFIELD_MAX; ...
        name.sfitAfit,   EFIELD_MAX}];
      VATTRIB.VAR_TYPE = [VATTRIB.VAR_TYPE; {...
        name.sfits.(sdpPair{iPair}), 'data'; ...
        name.sfitSdev,   'support_data'; ...
        name.sfitAfit,   'support_data'}];
    end
    
    if(~no_CMD)
      cmdmodel = mms_sdp_typecast('dce', cmdmodel);
      name.cmdmodel = [datasetPrefix '_cmdmodel_' varNameSuffix];
      outVars = [outVars {name.cmdmodel, cmdmodel}];
      recBound = [recBound {name.cmdmodel}];
      varDatatype = [varDatatype {name.cmdmodel, getfield(mms_sdp_typecast('dce'), 'cdf')}];
      compressVars = [compressVars {name.cmdmodel, COMPRESS_LEVEL}];
      % Update VATTRIB
      VATTRIB.CATDESC = [VATTRIB.CATDESC; {name.cmdmodel, 'CMD Model'}];
      VATTRIB.DEPEND_0 = [VATTRIB.DEPEND_0; {name.cmdmodel, name.epoch}];
      VATTRIB.DISPLAY_TYPE = [VATTRIB.DISPLAY_TYPE; {name.cmdmodel, 'time_series'}];
      VATTRIB.FIELDNAM = [VATTRIB.FIELDNAM; {name.cmdmodel, 'CMD Model'}];
      VATTRIB.FILLVAL = [VATTRIB.FILLVAL; {name.cmdmodel, getfield(mms_sdp_typecast('dce'), 'fillval')}];
      VATTRIB.FORMAT = [VATTRIB.FORMAT; {name.cmdmodel, 'F8.3'}];
      VATTRIB.SI_CONVERSION = [VATTRIB.SI_CONVERSION; {name.cmdmodel, '1.0e-3>V m^-1'}];
      VATTRIB.TENSOR_ORDER = [VATTRIB.TENSOR_ORDER; {name.cmdmodel, mms_sdp_typecast('tensor_order',0)}];
      VATTRIB.UNITS = [VATTRIB.UNITS; {name.cmdmodel, 'mV/m'}];
      VATTRIB.VALIDMIN = [VATTRIB.VALIDMIN; {name.cmdmodel, -EFIELD_MAX}];
      VATTRIB.VALIDMAX = [VATTRIB.VALIDMAX; {name.cmdmodel, EFIELD_MAX}];
      VATTRIB.VAR_TYPE = [VATTRIB.VAR_TYPE; {name.cmdmodel, 'support_data'}];
    end
    
  case MMS_CONST.SDCProc.l2pre
    % L2Pre (new output: ADP separate, and 2d DCE from E12, E34 and 3rd
    % componenet from E*B = 0.)
    varNameSuffix = [tmModeStr, '_l2pre'];
    dataType = [tmModeStr '_' procName '_' DCE_FILE];
    dataDesc = sprintf(...
      'MMS %i dual probe %s (%s), two dimensional electric field.',...
      scId,procName,tmModeStr);
    
    l2pre = Dmgr.l2a;
    if mms_is_error(l2pre)
      errStr='Cannot output ''l2pre''';
      irf.log('critical', errStr); error('MATLAB:MMS_SDP_CDFWRITE:OUT', errStr);
    end
    
    epochTT = l2pre.dce.time;
    % Ensure dce is in correct class
    dsl = mms_sdp_typecast('dce', l2pre.dsl.data);
    adp = mms_sdp_typecast('dce', l2pre.adp);
    phase = mms_sdp_typecast('phase', l2pre.phase.data);
    adcdata = mms_sdp_typecast('adc_offset',[l2pre.adc_off.e12, l2pre.adc_off.e34]);
    sw_wake = mms_sdp_typecast('dce', l2pre.sw_wake_despun);
    spinEpoch = mms_sdp_typecast('dce',l2pre.spinEpoch.data);
    dsl_off = mms_sdp_typecast('dce', l2pre.dsl_offset);
    % FIXME: Should not use irf.nanmean when writing all delta offset records.
    % When all records are written, also include the epoch of spinsfits (or
    % write the delta_offsets computed from resampling to dce datas epoch.
    deltadata = mms_sdp_typecast('delta_offset',irf.nanmean([real(l2pre.delta_off), imag(l2pre.delta_off)]));
    bitmask = mms_sdp_typecast('bitmask', l2pre.dsl.bitmask);
    % and quality
    quality = mms_sdp_typecast('quality',mms_sdp_bitmask2quality('e',l2pre.dsl.bitmask));
    dplus   = mms_sdp_typecast('deltaplus', (10^9/(2*Dmgr.samplerate))); % in nanoseconds, half the time interval.
    
    name.epoch   = [datasetPrefix '_epoch_' varNameSuffix];
    name.adp     = [datasetPrefix '_adp_' varNameSuffix];
    name.adc     = [datasetPrefix '_adc_offset_' varNameSuffix];
    name.delta   = [datasetPrefix '_delta_offset_' varNameSuffix];
    name.swwake  = [datasetPrefix '_swwake_residue_' varNameSuffix];
    name.spinEpo = [datasetPrefix '_spin_residue_' varNameSuffix];
    name.phase   = [datasetPrefix '_phase_' varNameSuffix];
    name.dsl     = [datasetPrefix '_dce_dsl_' varNameSuffix];
    name.dsl_off = [datasetPrefix '_dce_dsl_offset_' varNameSuffix];
    name.bitmask = [datasetPrefix '_bitmask_' varNameSuffix];
    name.quality = [datasetPrefix '_quality_' varNameSuffix];
    name.label   = [datasetPrefix '_label1_' varNameSuffix]; % DCE data
    name.label2  = [datasetPrefix '_label2_' varNameSuffix]; % ADC offsets
    name.label3  = [datasetPrefix '_label3_' varNameSuffix]; % Delta offsets
    name.dplus   = [datasetPrefix '_deltap_' varNameSuffix]; % Delta Plus (time interval)
    name.repres1 = [datasetPrefix '_representation1_' varNameSuffix];
    name.repres2 = [datasetPrefix '_representation2_' varNameSuffix];
    label        = ['Ex DSL'; 'Ey DSL'; 'Ez DSL'];
    label2       = ['E_12'; 'E_34'];
    label3       = ['Delta Ex DSL'; 'Delta Ey DSL'];
    repres1      = ['x'; 'y'; 'z'];
    repres2      = ['x'; 'y'];
    
    outVars = {name.epoch, epochTT, name.label, label, name.adp, adp, ...
      name.phase, phase, name.dsl, dsl, name.bitmask, bitmask, ...
      name.quality, quality, name.label2, label2, name.adc, adcdata,...
      name.label3, label3, name.delta, deltadata, ...
      name.swwake, sw_wake, name.spinEpo, spinEpoch, ...
      name.dplus, dplus, name.repres1, repres1, ...
      name.repres2, repres2, name.dsl_off, dsl_off};
    % RecordBound, ie individual cdf records for each row.
    % FIXME: When all delta_offset values inclunde also delta in recBound
    recBound = {name.epoch, name.dsl, name.phase, name.bitmask, ...
      name.quality, name.adp, name.adc, name.swwake, name.spinEpo, name.dsl_off};
    %Variable Datatypes
    varDatatype = {name.epoch, getfield(mms_sdp_typecast('epoch'),'cdf'), ...
      name.label,   getfield(mms_sdp_typecast('label'),'cdf'), ...
      name.label2,  getfield(mms_sdp_typecast('label'),'cdf'), ...
      name.label3,  getfield(mms_sdp_typecast('label'),'cdf'), ...
      name.adp,     getfield(mms_sdp_typecast('dce'),'cdf'),...
      name.phase,   getfield(mms_sdp_typecast('phase'),'cdf'),...
      name.dsl,     getfield(mms_sdp_typecast('dce'),'cdf'), ...
      name.bitmask, getfield(mms_sdp_typecast('bitmask'),'cdf'),...
      name.quality, getfield(mms_sdp_typecast('quality'),'cdf'),...
      name.adc,     getfield(mms_sdp_typecast('adc_offset'),'cdf'),...
      name.delta,   getfield(mms_sdp_typecast('delta_offset'),'cdf'), ...
      name.swwake,  getfield(mms_sdp_typecast('dce'),'cdf'), ...
      name.spinEpo, getfield(mms_sdp_typecast('dce'),'cdf'), ...
      name.dplus,   getfield(mms_sdp_typecast('deltaplus'),'cdf'), ...
      name.repres1, getfield(mms_sdp_typecast('label'),'cdf'), ...
      name.repres2, getfield(mms_sdp_typecast('label'),'cdf'), ...
      name.dsl_off, getfield(mms_sdp_typecast('dce'),'cdf')};
    % Compression level for each variable. Note: Not for TT2000 epoch.
    compressVars = {name.label, COMPRESS_LEVEL, name.label2, COMPRESS_LEVEL,...
      name.label3, COMPRESS_LEVEL, name.adp, COMPRESS_LEVEL,...
      name.phase, COMPRESS_LEVEL, name.dsl, COMPRESS_LEVEL, ...
      name.bitmask, COMPRESS_LEVEL, name.quality, COMPRESS_LEVEL, ...
      name.adc, COMPRESS_LEVEL, name.delta, COMPRESS_LEVEL, ...
      name.swwake, COMPRESS_LEVEL, name.spinEpo, COMPRESS_LEVEL, ...
      name.dplus, COMPRESS_LEVEL, name.repres1, COMPRESS_LEVEL, ...
      name.repres2, COMPRESS_LEVEL, name.dsl_off, COMPRESS_LEVEL};
    
    %% Update VariableAttributes
    VATTRIB.CATDESC = {name.epoch, 'Time tags, in TT2000'; ...
      name.label,   'Label'; ...
      name.label2,  'Label'; ...
      name.label3,  'Label'; ...
      name.adp,     'Ez DSL from ADP (E56)';...
      name.phase,   'Spacecraft phase calculated from DEFATT (0 deg when SC X closest to sunward direction)';...
      name.dsl,     'DC E field in DSL frame of reference, Ez computed from B*E=0';...
      name.bitmask, 'Status bitmask';...
      name.quality, 'Quality indicator (3 good), (2 ok data, use with some caution), (1 bad data, use with caution), (0 Really bad data or no data at all)';...
      name.adc,     'ADC offsets which has been removed from DC E DSL';...
      name.delta,   'Delta offset';...
      name.swwake,  'Solar wind wake removed from data measurements (despun to DSL).'; ...
      name.spinEpo, 'Spin epoch removed from data measurements.'; ...
      name.dplus,   'Delta plus/minus, time interval during which the data was measured'; ...
      name.repres1, 'Representation'; ...
      name.repres2, 'Representation'; ...
      name.dsl_off, 'DSL offset removed from DCE E DSL'};
    VATTRIB.COORDINATE_SYSTEM = {name.adp, 'DSL'; ...
      name.dsl,   'DSL'; ...
      name.swwake, 'DSL'; ...
      name.spinEpo, 'DSL'; ...
      name.delta, 'DSL'; ...
      name.dsl_off, 'DSL'};
    VATTRIB.DELTA_PLUS_VAR = {name.epoch, name.dplus};
    VATTRIB.DELTA_MINUS_VAR = {name.epoch, name.dplus};
    % FIXME: When all delta_offset values inclunde also delta in DEPEND_O, with
    % reference to its epoch.
    VATTRIB.DEPEND_0 = {name.dsl,     name.epoch; ...
      name.adp,     name.epoch;...
      name.phase,   name.epoch;...
      name.bitmask, name.epoch;...
      name.quality, name.epoch;...
      name.adc,     name.epoch;...
      name.spinEpo, name.epoch;...
      name.swwake,  name.epoch;...
      name.dsl_off, name.epoch};
    VATTRIB.DISPLAY_TYPE = {name.dsl, 'time_series'; ...
      name.adp, 'time_series'; ...
      name.dsl_off, 'time_series'};
    VATTRIB.FIELDNAM = {name.epoch, 'Time tags'; ...
      name.label,   'Label'; ...
      name.label2,  'Label';...
      name.label3,  'Label';...
      name.adp,     'Ez DSL (ADP)'; ...
      name.phase,   'Phase (SC X = 0 deg)';...
      name.dsl,     'DC E field (dsl)';...
      name.bitmask, 'Status bitmask';...
      name.quality, 'Quality indicator';...
      name.adc,     'ADC offset';...
      name.delta,   'Delta offset';...
      name.swwake,  'SW wake subtracted and despun';...
      name.spinEpo, 'Spin epoch subtracted';...
      name.dplus,   'Delta plus/minus';...
      name.dsl_off, 'DSL offset'; ...
      name.repres1, 'Representation'; ...
      name.repres2, 'Representation'};
    VATTRIB.FILLVAL = {name.epoch, getfield(mms_sdp_typecast('epoch'),'fillval'); ...
      name.dsl,     getfield(mms_sdp_typecast('dce'),'fillval');...
      name.adp,     getfield(mms_sdp_typecast('dce'),'fillval');...
      name.phase,   getfield(mms_sdp_typecast('phase'),'fillval');...
      name.bitmask, getfield(mms_sdp_typecast('bitmask'),'fillval');...
      name.quality, getfield(mms_sdp_typecast('quality'),'fillval');...
      name.adc,     getfield(mms_sdp_typecast('adc_offset'),'fillval');...
      name.delta,   getfield(mms_sdp_typecast('delta_offset'),'fillval'); ...
      name.swwake,  getfield(mms_sdp_typecast('dce'),'fillval');...
      name.spinEpo, getfield(mms_sdp_typecast('dce'),'fillval');...
      name.dplus,   getfield(mms_sdp_typecast('deltaplus'),'fillval');...
      name.dsl_off, getfield(mms_sdp_typecast('dce'),'fillval')};
    VATTRIB.FORMAT = {name.label,   'A23'; ...
      name.label2,  'A23'; ...
      name.label3,  'A23'; ...
      name.dsl,     'F8.3';...
      name.phase,   'F8.3';...
      name.adp,     'F8.3';...
      name.bitmask, 'I7';...
      name.quality, 'I7';...
      name.adc,     'F8.3';...
      name.delta,   'F8.3'; ...
      name.swwake,  'F8.3'; ...
      name.spinEpo, 'F8.3'; ...
      name.dsl_off, 'F8.3'; ...
      name.dplus,   'I19'; ...
      name.repres1, 'A23'; ...
      name.repres2, 'A23'};
    VATTRIB.LABLAXIS = {name.adp, 'Ez DSL (ADP)'};
    VATTRIB.LABL_PTR_1 = {name.dsl, name.label;...
      name.adc,   name.label2;...
      name.delta, name.label3;...
      name.spinEpo, name.label;...
      name.swwake, name.label3;...
      name.dsl_off, name.label3};
    VATTRIB.REPRESENTATION_1 = {name.adp, 'z'; ...
      name.dsl, name.repres1; ...
      name.spinEpo, name.repres1; ...
      name.swwake, name.repres2; ...
      name.delta, name.repres2; ...
      name.dsl_off, name.repres2};
    VATTRIB.SI_CONVERSION = {name.dsl,     '1.0e-3>V m^-1'; ...
      name.adp,     '1.0e-3>V m^-1';...
      name.phase,   '0.0174532925>rad';...
      name.bitmask, ' > ';...
      name.quality, ' > ';...
      name.adc,     '1.0e-3>V m^-1';...
      name.delta,   '1.0e-3>V m^-1'; ...
      name.swwake,  '1.0e-3>V m^-1'; ...
      name.spinEpo, '1.0e-3>V m^-1'; ...
      name.dplus,   '1.0e-9>s'; ...
      name.dsl_off, '1.0e-3>V m^-1'};
    VATTRIB.TIME_BASE = {name.epoch, 'J2000'};
    VATTRIB.TENSOR_ORDER = {name.dsl, mms_sdp_typecast('tensor_order',1); ...
      name.phase,   mms_sdp_typecast('tensor_order',0); ...
      name.adp,     mms_sdp_typecast('tensor_order',1); ...
      name.bitmask, mms_sdp_typecast('tensor_order',0); ...
      name.quality, mms_sdp_typecast('tensor_order',0); ...
      name.adc,     mms_sdp_typecast('tensor_order',0); ...
      name.delta,   mms_sdp_typecast('tensor_order',1)};
    VATTRIB.UNITS = {name.epoch, 'ns'; ...
      name.adp,     'mV/m'; ...
      name.phase,   'deg';...
      name.dsl,     'mV/m'; ...
      name.bitmask, ' ';...
      name.quality, ' ';...
      name.adc,     'mV/m';...
      name.delta,   'mV/m';...
      name.swwake,  'mV/m';...
      name.spinEpo, 'mV/m';...
      name.dsl_off, 'mV/m';...
      name.dplus,   'ns'};
    VATTRIB.VALIDMIN = {name.epoch, spdfcomputett2000([1990,01,01,0,0,0,0,0,0]); ...
      name.dsl,     -EFIELD_MAX;...
      name.adp,     -EFIELD_MAX; ...
      name.phase,   mms_sdp_typecast('phase',0);...
      name.bitmask, mms_sdp_typecast('bitmask',0);...
      name.quality, mms_sdp_typecast('quality',0);...
      name.adc,     -EFIELD_MAX;...
      name.delta,   -EFIELD_MAX; ...
      name.swwake,  -EFIELD_MAX; ...
      name.spinEpo,  -EFIELD_MAX; ...
      name.dsl_off, -EFIELD_MAX; ...
      name.dplus,   mms_sdp_typecast('deltaplus', 30517)};  % floor(10^9/(2*16384)), highest brst rounded down
    VATTRIB.VALIDMAX = {name.epoch, spdfcomputett2000([2100,01,01,0,0,0,0,0,0]); ...
      name.dsl,     EFIELD_MAX;...
      name.adp,     EFIELD_MAX;...
      name.phase,   mms_sdp_typecast('phase',360);...
      name.bitmask, mms_sdp_typecast('bitmask',65534);...
      name.quality, QUALITY_MAX;...
      name.adc,     EFIELD_MAX;...
      name.swwake,  EFIELD_MAX; ...
      name.spinEpo,  EFIELD_MAX; ...
      name.delta,   EFIELD_MAX; ...
      name.dsl_off, EFIELD_MAX; ...
      name.dplus,   mms_sdp_typecast('deltaplus',62500000)}; % int64(10^9/(2*8)), lowest comm
    VATTRIB.VAR_TYPE = {name.epoch, 'support_data'; ...
      name.label,   'metadata'; ...
      name.label2,  'metadata'; ...
      name.label3,  'metadata'; ...
      name.dsl,     'data';...
      name.adp,     'data';...
      name.phase,   'support_data';...
      name.bitmask, 'support_data';...
      name.quality, 'support_data';...
      name.adc,     'support_data';...
      name.swwake,  'support_data'; ...
      name.spinEpo,  'support_data'; ...
      name.dsl_off,  'support_data'; ...
      name.delta,   'support_data'; ...
      name.dplus,   'support_data';...
      name.repres1, 'metadata'; ...
      name.repres2, 'metadata'};
    VATTRIB.MONOTON = {name.epoch, 'INCREASE'};
    
    
  case MMS_CONST.SDCProc.scpot
    % ScPot - get data
    varNameSuffix = [tmModeStr, '_l2'];
    dataType = [varNameSuffix, '_scpot'];
    dataDesc = sprintf(...
      'MMS %i dual probe %s (%s), Spacecraft potential',...
      scId,procName,tmModeStr);
    
    dcv = Dmgr.dcv;
    if mms_is_error(dcv)
      errStr='Cannot output ''dcv''';
      irf.log('critical', errStr); error('MATLAB:MMS_SDP_CDFWRITE:OUT', errStr);
    end
    probe2sc_pot = Dmgr.probe2sc_pot;
    if mms_is_error(probe2sc_pot)
      errStr='Cannot output ''probe2sc_pot''';
      irf.log('critical', errStr); error('MATLAB:MMS_SDP_CDFWRITE:OUT', errStr);
    end
    sc_pot = Dmgr.sc_pot;
    if mms_is_error(sc_pot)
      errStr='Cannot output ''sc_pot''';
      irf.log('critical', errStr); error('MATLAB:MMS_SDP_CDFWRITE:OUT', errStr);
    end
    
    epochTT = dcv.time;
    % psp_p, PSP, ESCP stored as CDF_REAL4 (single in Matlab)
    psp_p = mms_sdp_typecast('scpot',[dcv.v1.data, dcv.v2.data, dcv.v3.data, ...
      dcv.v4.data, dcv.v5.data, dcv.v6.data]);
    PSP     = mms_sdp_typecast('scpot',  probe2sc_pot.data);
    ESCP    = mms_sdp_typecast('scpot',  sc_pot.data);
    bitmask = mms_sdp_typecast('bitmask',sc_pot.bitmask);
    quality = mms_sdp_typecast('quality',mms_sdp_bitmask2quality('e',sc_pot.bitmask));
    dplus   = mms_sdp_typecast('deltaplus', (10^9/(2*Dmgr.samplerate))); % in nanoseconds, half the time interval.
    
    name.epoch   = [datasetPrefix '_epoch_' varNameSuffix]; % Timestamp in TT2000
    name.scpot   = [datasetPrefix '_scpot_' varNameSuffix]; % Estimated Spacecraft potential
    name.psp     = [datasetPrefix '_psp_' varNameSuffix]; % Probe to spacecraft potential, averaged
    name.psp_p   = [datasetPrefix '_dcv_' varNameSuffix]; % Probe to spacecraft potential, indiv probes
    name.bitmask = [datasetPrefix '_bitmask_' varNameSuffix]; % Bitmask
    name.quality = [datasetPrefix '_quality_' varNameSuffix]; % Quality
    name.label   = [datasetPrefix '_label1_' varNameSuffix];
    name.dplus   = [datasetPrefix '_deltap_' varNameSuffix]; % Delta Plus (time interval)
    
    label = ['PSP_P1'; 'PSP_P2'; 'PSP_P3'; 'PSP_P4'; 'PSP_P5'; 'PSP_P6'];
    
    outVars = {name.epoch, epochTT, ...
      name.label, label, ...
      name.scpot, ESCP, ...
      name.psp, PSP, ...
      name.psp_p, psp_p, ...
      name.bitmask, bitmask,...
      name.quality, quality, ...
      name.dplus, dplus};
    
    % RecordBound, ie individual cdf records for each row.
    recBound = {name.epoch, name.scpot, name.psp, name.psp_p, ...
      name.bitmask, name.quality};
    
    % Variable Datatypes
    varDatatype = {name.epoch, getfield(mms_sdp_typecast('epoch'),'cdf'), ...
      name.label,   getfield(mms_sdp_typecast('label'),  'cdf'), ...
      name.scpot,   getfield(mms_sdp_typecast('scpot'),  'cdf'), ...
      name.psp,     getfield(mms_sdp_typecast('scpot'),  'cdf'), ...
      name.psp_p,   getfield(mms_sdp_typecast('scpot'),  'cdf'),...
      name.bitmask, getfield(mms_sdp_typecast('bitmask'),'cdf'), ...
      name.quality, getfield(mms_sdp_typecast('quality'),'cdf'), ...
      name.dplus,   getfield(mms_sdp_typecast('deltaplus'),'cdf')};
    
    % Compression
    compressVars = {name.label, COMPRESS_LEVEL, name.scpot, COMPRESS_LEVEL, ...
      name.psp, COMPRESS_LEVEL, name.psp_p, COMPRESS_LEVEL, ...
      name.bitmask, COMPRESS_LEVEL, name.quality, COMPRESS_LEVEL, ...
      name.dplus, COMPRESS_LEVEL};
    
    %% Update VariableAttributes
    VATTRIB.CATDESC = {name.epoch, 'Time tags, in TT2000'; ...
      name.label,   'Label'; ...
      name.scpot,   'Spacecraft potential';...
      name.psp,     'Probe to spacecraft potential, averaged'; ...
      name.psp_p,   'Individual probes. P1=V1, P2=(V1-0.120*E12), P3=V3, P4=(V3-0.120*E34), P5=V5, P6=(V5-0.0292*E56)'; ...
      name.bitmask, 'Status bitmask';...
      name.quality, 'Quality indicator (3 good), (2 ok data, use with some caution), (1 bad data, use with caution), (0 Really bad data or no data at all)';...
      name.dplus,   'Delta plus/minus, time interval during which the data was measured'};
    VATTRIB.DELTA_PLUS_VAR = {name.epoch, name.dplus};
    VATTRIB.DELTA_MINUS_VAR = {name.epoch, name.dplus};
    VATTRIB.DEPEND_0 = {name.scpot, name.epoch; ...
      name.psp,     name.epoch; ...
      name.psp_p,   name.epoch; ...
      name.bitmask, name.epoch;...
      name.quality, name.epoch};
    VATTRIB.DISPLAY_TYPE = {name.scpot, 'time_series'; ...
      name.psp,     'time_series'; ...
      name.psp_p,   'time_series';...
      name.quality, 'time_series'};
    VATTRIB.FIELDNAM = {name.epoch, 'Time tags'; ...
      name.label,   'Label'; ...
      name.scpot,   'Spacecraft potential'; ...
      name.psp,     'Probe to spacecraft potential'; ...
      name.psp_p,   'Probe to spacecraft potential individual probe'; ...
      name.bitmask, 'Status bitmask';...
      name.quality, 'Quality indicator';...
      name.dplus,   'Delta plus/minus'};
    VATTRIB.FILLVAL = {name.epoch, getfield(mms_sdp_typecast('epoch'),'fillval'); ...
      name.scpot,   getfield(mms_sdp_typecast('scpot'),  'fillval'); ...
      name.psp,     getfield(mms_sdp_typecast('scpot'),  'fillval'); ...
      name.psp_p,   getfield(mms_sdp_typecast('scpot'),  'fillval'); ...
      name.bitmask, getfield(mms_sdp_typecast('bitmask'),'fillval');...
      name.quality, getfield(mms_sdp_typecast('quality'),'fillval'); ...
      name.dplus,   getfield(mms_sdp_typecast('deltaplus'),'fillval')};
    VATTRIB.FORMAT = {name.scpot, 'F8.3'; ...
      name.label,   'A23'; ...
      name.psp,     'F8.3'; ...
      name.psp_p,   'F8.3'; ...
      name.bitmask, 'I7';...
      name.quality, 'I7'; ...
      name.dplus,   'I19'};
    VATTRIB.LABLAXIS = {name.scpot, 'ScPot';
      name.psp,     'Probe2Sc pot';...
      name.quality, 'ScPot quality';...
      name.bitmask, 'Bitmask'};
    VATTRIB.LABL_PTR_1 = {name.psp_p, name.label};
    VATTRIB.SI_CONVERSION = {name.scpot, '1.0>V'; ...
      name.psp,     '1.0>V'; ...
      name.psp_p,   '1.0>V'; ...
      name.bitmask, ' > ';...
      name.quality, ' > ';...
      name.dplus,   '1.0e-9>s'};
    VATTRIB.TIME_BASE = {name.epoch, 'J2000'};
    VATTRIB.TENSOR_ORDER = {name.scpot, mms_sdp_typecast('tensor_order',0); ...
      name.psp,     mms_sdp_typecast('tensor_order',0); ...
      name.psp_p,   mms_sdp_typecast('tensor_order',0); ...
      name.bitmask, mms_sdp_typecast('tensor_order',0); ...
      name.quality, mms_sdp_typecast('tensor_order',0)};
    VATTRIB.UNITS = {name.epoch, 'ns'; ...
      name.scpot,   'V'; ...
      name.psp,     'V'; ...
      name.psp_p,   'V'; ...
      name.bitmask, ' ';...
      name.quality, ' ';...
      name.dplus,   'ns'};
    VATTRIB.VALIDMIN = {name.epoch, spdfcomputett2000([1990,01,01,0,0,0,0,0,0]); ...
      name.scpot,   VOLTAGE_MIN; ...
      name.psp,     VOLTAGE_MIN; ...
      name.psp_p,   VOLTAGE_MIN; ...
      name.bitmask, mms_sdp_typecast('bitmask',0);...
      name.quality, mms_sdp_typecast('quality',0); ...
      name.dplus,   mms_sdp_typecast('deltaplus', 30517)}; % floor(10^9/(2*16384)), highest brst rounded down
    VATTRIB.VALIDMAX = {name.epoch, spdfcomputett2000([2100,01,01,0,0,0,0,0,0]); ...
      name.scpot,   VOLTAGE_MAX; ...
      name.psp,     VOLTAGE_MAX; ...
      name.psp_p,   VOLTAGE_MAX; ...
      name.bitmask, mms_sdp_typecast('bitmask',65534);...
      name.quality, QUALITY_MAX; ...
      name.dplus,   mms_sdp_typecast('deltaplus',62500000)}; % int64(10^9/(2*8)), lowest comm
    VATTRIB.VAR_TYPE = {name.epoch, 'support_data'; ...
      name.label,   'metadata'; ...
      name.scpot,   'data'; ...
      name.psp,     'data'; ...
      name.psp_p,   'data'; ...
      name.bitmask, 'support_data';...
      name.quality, 'support_data'; ...
      name.dplus,   'support_data'};
    VATTRIB.MONOTON = {name.epoch, 'INCREASE'};
    
    %% Update GlobalAttribute
    % ref: https://heliophysicsdata.gsfc.nasa.gov/queries/CDAWeb_SPASE.html
    % (as per 2022-08-30T11:30 CEST)
    switch tmMode
      case MMS_CONST.TmMode.brst
        GATTRIB.spase_DatasetResourceID = {sprintf('spase://NASA/NumericalData/MMS/%i/FIELDS/EDP/Burst/Level2/SpacecraftPotential/PT0.0001220703125S', scId)};
        switch scId
          case 1
            doiSuffix = '7t5y-eq71';
          case 2
            doiSuffix = 'a6r6-hr28';
          case 3
            doiSuffix = 'x3td-gh63';
          case 4
            doiSuffix = 'j5ge-t096';
          otherwise
            errStr = 'MMS scId must be one of [1, 2, 3 or 4].';
            irf.log('critical', errStr);
            error('MATLAB:MMS_SDP_CDFWRITE:OUT', errStr);
        end
      case MMS_CONST.TmMode.fast
        GATTRIB.spase_DatasetResourceID = {sprintf('spase://NASA/NumericalData/MMS/%i/FIELDS/EDP/Fast/Level2/SpacecraftPotential/PT0.03125S', scId)};
        switch scId
          case 1
            doiSuffix = 'jjsp-6g51';
          case 2
            doiSuffix = 'myvz-be60';
          case 3
            doiSuffix = 'kzh6-vf67';
          case 4
            doiSuffix = '194m-pq72';
          otherwise
            errStr = 'MMS scId must be one of [1, 2, 3 or 4].';
            irf.log('critical', errStr);
            error('MATLAB:MMS_SDP_CDFWRITE:OUT', errStr);
        end
      case MMS_CONST.TmMode.slow
        GATTRIB.spase_DatasetResourceID = {sprintf('spase://NASA/NumericalData/MMS/%i/FIELDS/EDP/Slow/Level2/SpacecraftPotential/PT0.125S', scId)};
        switch scId
          case 1
            doiSuffix = '5t77-ka57';
          case 2
            doiSuffix = 'mgay-bk26';
          case 3
            doiSuffix = '5vc4-ys82';
          case 4
            doiSuffix = 't44j-x227';
          otherwise
            errStr = 'MMS scId must be one of [1, 2, 3 or 4].';
            irf.log('critical', errStr);
            error('MATLAB:MMS_SDP_CDFWRITE:OUT', errStr);
        end
      otherwise
        % error
    end
    GATTRIB.DOI = {['https://doi.org/10.48322/', doiSuffix]};

  otherwise
    errStr = 'unrecognized procId';
    irf.log('critical', errStr); error(errStr)
end

%% Write to file.
% Update GlobalAttributes.
GATTRIB.Data_type = {dataType}; % 'fast_l1b_dce2d', 'slow_l1b_dce2d' or 'brst_l1b_dce2d'.
GATTRIB.Logical_source = {[datasetPrefix '_' dataType]}; % ie. mms2_edp_fast_l1b_OptDesc FIXME...
GATTRIB.Logical_source_description = {dataDesc}; % in full words.
if(~isempty(Dmgr.calFile))
  GATTRIB.Calibration_file = {Dmgr.calFile}; % Calibration file used.
end

% Replace any NaN with correct FILLVAL
replaceNaN()

write_file()

% Return to previous working directory.
cd(oldDir);

%% Help functions
  function [fileName, verStr] = get_file_name
    % Generate output file name incrementing the file version if necessary
    switch procId
      case MMS_CONST.SDCProc.ql
        subDir = procName; suf = 'dce2d';
      case MMS_CONST.SDCProc.l2pre
        subDir = 'l2pre'; suf = 'dce2d';
      case MMS_CONST.SDCProc.scpot
        subDir = 'l2'; suf = 'scpot';
      case MMS_CONST.SDCProc.l2a
        subDir = 'l2a'; suf = 'dce2d';
      otherwise
        errStr = 'unrecognized procId';
        irf.log('critical', errStr); error(errStr)
    end
    scIdStr = sprintf('mms%d',scId);
    startTime =  HeaderInfo.startTime;
    verStr = sprintf('%d.%d.',MMS_CONST.Version.(procName).X, MMS_CONST.Version.(procName).Y);
    fileName = [scIdStr '_' INST_NAME, '_' tmModeStr '_' subDir '_' ...
      suf '_' startTime '_v' ];
    
    % Check for preexisting files and increment file version
    switch tmMode
      case MMS_CONST.TmMode.brst
        dataPathPref = [ENVIR.DATA_PATH_ROOT, filesep, scIdStr, filesep, ...
          INST_NAME, filesep, tmModeStr, filesep, subDir, filesep, suf, ...
          filesep, startTime(1:4), filesep, startTime(5:6), filesep, ...
          startTime(7:8), filesep];
      otherwise
        dataPathPref = [ENVIR.DATA_PATH_ROOT, filesep, scIdStr, filesep, ...
          INST_NAME, filesep, tmModeStr, filesep, subDir, filesep, suf, ...
          filesep, startTime(1:4), filesep, startTime(5:6), filesep];
    end
    preExistingFiles = dir([dataPathPref fileName verStr '*.cdf']);
    if numel(preExistingFiles)
      maxRev = 0;
      for iFile = 1:numel(preExistingFiles)
        rev = get_rev(preExistingFiles(iFile).name);
        if rev>maxRev, maxRev = rev; end
      end
      newVer = maxRev + 1;
    else, newVer = 0;
    end
    verStr = [verStr num2str(newVer)];
    fileName = [fileName verStr];
    
    function r = get_rev(s)
      % Find revision (Z) from version string in a file name xxx_vX.Y.Z.cdf
      idxDot = find(s=='.');
      if numel(idxDot)~=3
        irf.log('warning',['Bad file name: ' s])
        r = 0; return
      end
      r = str2double(s(idxDot(2)+1:idxDot(3)-1));
    end % GET_REV
  end % get_file_name

  function replaceNaN
    % NaN is not ISTP compliant in CDF files and should not be used for the
    % MMS mission, however it can be written/created in CDF files therefor
    % replace any found NaN with the corresponding correct FillValue as
    % specified for that variable.
    for ii=1:2:size(outVars,2)
      % outVars = {'varName', data}, but may include variables without
      % FillVal (such as labels).
      ind = find(strcmp(VATTRIB.FILLVAL(:,1), outVars{1,ii})>0);
      if ind
        % Variable (ind) has a FILLVAL, locate any NaN and replace them
        outVars{1,ii+1}(isnan(outVars{1,ii+1}))=VATTRIB.FILLVAL{ind,2};
      end
    end
  end

  function write_file
    % write file with arguments obtained above, also include md5 checksum.
    spdfcdfwrite(outFileName, outVars, 'Vardatatypes', varDatatype, ...
      'GlobalAttributes', GATTRIB, 'VariableAttributes', VATTRIB, ...
      'RecordBound', recBound, 'VarCompress', compressVars, ...
      'Checksum', 'md5');
    irf.log('notice',['File written to DROPBOX_ROOT/',outFileName,'.cdf']);
  end

  function GATTRIB = getGlobalAttributes
    %% Create GlobalAttribute struct
    % Source: MMS_CDF_Format_Guide, v1.7 draft, issued 2014/10/11.
    GATTRIB=[];
    % Global Attributes REQUIRED:
    GATTRIB.Data_type = cell(0,1); % mode_dataLevel_optionalDescriptor
    GATTRIB.Data_version = cell(0,1); % Same as version number in filename.
    GATTRIB.Descriptor = {'EDP>Electric Double Probe'};
    GATTRIB.Discipline = {'Space Physics>Magnetospheric Science'};
    GATTRIB.DOI = cell(0,1); % NASA req. for public data products (ie our L2 scpot), otherwise just recommended
    GATTRIB.Calibration_file = cell(0,1); % Name of calibration file used.
    GATTRIB.Generation_date = {char(datetime("now","Format","uuuuMMdd"))};
    GATTRIB.Instrument_type = {'Electric Fields (space)'};
    GATTRIB.Logical_file_id = cell(0,1); % Same as filename without ".cdf".
    GATTRIB.Logical_source = cell(0,1); % Ex: mms3_edp_fast_ql_swd (mmsSC_instrument_mode_dataLevel_optionalDescriptor)
    GATTRIB.Logical_source_description = cell(0,1); % Description in full words..
    GATTRIB.File_naming_convention = {'source_descriptor_datatype_yyyyMMddHHmmss'};
    GATTRIB.Mission_group = {'MMS'};
    GATTRIB.PI_affiliation = {'SWRI, LASP, KTH'};
    GATTRIB.PI_name = {'J.Burch, R.Ergun, P.Lindqvist.'};
    GATTRIB.Project = {'STP>Solar-Terrestrial Physics'};
    GATTRIB.spase_DatasetResourceID = cell(0,1); % NASA req. for public data products (ie our L2 scpot), otherwise just recommended
    GATTRIB.Source_name = {sprintf('MMS%i>MMS Satellite Number %i',scId,scId)}; % Or possibly 'MMS>MMS Constellation'.
    GATTRIB.TEXT = {'https://mms.gsfc.nasa.gov/'; ...
      ['The full name of PI affiliations: SWRI - Southwest Research Institute. ',...
      'LASP - Laboratory for Atmospheric and Space Physics. ',...
      'KTH - Kungliga Tekniska Hogskolan (Swedish Royal Institute of Technology). ']; ...
      'For detailed timing information, such as needed for cross spectral analysis, please consult the EDP Data Products Guide.' };  % FIXME This attribute is an SPDF standard global attribute, which is a text description of the
    %experiment whose data is included in the CDF. A reference to a journal article(s) or to a
    %World Wide Web page describing the experiment is essential, and constitutes the
    %minimum requirement. A written description of the data set is also desirable. This
    %attribute can have as many entries as necessary to contain the desired information.
    %Typically, this attribute is about a paragraph in length and is not shown on CDAWeb.
    % Note: Matlab & spdcdfwrite to cdf files result in issues with ASCII
    % for the charachter "??", therefor replace ?? with o.
    GATTRIB.HTTP_LINK = {'https://mms.gsfc.nasa.gov/'; 'http://mms.space.swri.edu/'}; % FIXME should point to data
    GATTRIB.LINK_TEXT = {'Magnetospheric Multiscale (MMS) mission home page'; 'SMART package home page'}; % FIXME as well
    GATTRIB.LINK_TITLE = {'At NASA GSFC'; 'At SWRI'}; % FIXME as well
    GATTRIB.MODS = MMS_CONST.Version.MODS; % Text describing major version changes, ie. "vX" changes.
    % Global Attributes RECOMMENDED:
    GATTRIB.Acknowledgement = cell(0,1);
    % System used (IRFU: "spis"/"brain", SDC: "sdc", other)
    [~, sysName] = system('hostname');
    if(regexpi(sysName,'spis|brain|thonilaptop'))
      GATTRIB.Generated_by = {['Y.Khotyaintsev and T.Nilsson, IRFU, using IRFU Matlab', irf('version'), ' while running at IRFU.']};
    elseif(regexpi(sysName,'sdc'))
      GATTRIB.Generated_by = {['Y.Khotyaintsev and T.Nilsson, IRFU, using IRFU Matlab', irf('version'), ' while running at SDC.']};
    else
      GATTRIB.Generated_by = {['Y.Khotyaintsev and T.Nilsson, IRFU, using IRFU Matlab', irf('version')]};
    end
    % Global Attributes OPTIONAL:
    %    GATTRIB.Parents = cell(0,1); % Req if number of source cdf >= 2.
    GATTRIB.Skeleton_version = {'v0.0.8'};
    GATTRIB.Rules_of_use = cell(0,1);
    GATTRIB.Time_resolution = cell(0,1);
  end

  function VATTRIB = getVariableAttributes
    %% Create VariableAttribute struct
    VATTRIB=[];
    % Variable attributes, REQUIRED as specified.
    VATTRIB.CATDESC = cell(0,1);        % Req for data, support_data and meta_data.
    VATTRIB.COORDINATE_SYSTEM = cell(0,1); % Strongly recommended for vector/tensors/quaternions.
    VATTRIB.DELTA_PLUS_VAR = cell(0,1); % Strongly recommended for interval variables, such as sampling time for the Epochs
    VATTRIB.DELTA_MINUS_VAR = cell(0,1); % Strongly recommended for interval variables,
    VATTRIB.DEPEND_0 = cell(0,1);       % Req for data, support_data and meta_data (if timevarying).
    VATTRIB.DEPEND_1 = cell(0,1);         % Req if variable is not using DEPEND_0.
    VATTRIB.DISPLAY_TYPE = cell(0,1);   % Req for data.
    VATTRIB.FIELDNAM = cell(0,1);       % Req for data, support_data, meta_data.
    VATTRIB.FILLVAL = cell(0,1);        % Req for data, support_data, meta_data (if timevarying).
    VATTRIB.FORMAT = cell(0,1);         % Req for data, support_data, meta_data.
    VATTRIB.FORM_PTR = cell(0,1);         % Req if variable is not using FORMAT.
    VATTRIB.LABLAXIS = cell(0,1);       % Req for data.
    VATTRIB.LABL_PTR_1 = cell(0,1);       % Req if variable is not using LABLAXIS.
    VATTRIB.REPRESENTATION_1 = cell(0,1); % Strongly recommended for vector/tensors/quaternions.
    VATTRIB.SI_CONVERSION = cell(0,1);  % Req for data.
    VATTRIB.TENSOR_ORDER = cell(0,1);     % Strongly recommended for vector/tensors/quaternions. (vector=1, pressure tensor=2, etc).
    VATTRIB.UNITS = cell(0,1);          % Req for data, support_data.
    VATTRIB.UNIT_PTR = cell(0,1);         % Req if variable is not using UNITS.
    VATTRIB.VALIDMIN = cell(0,1);       % Req for data, support_data (if timevarying).
    VATTRIB.VALIDMAX = cell(0,1);       % Req for data, support_data (if timevarying).
    VATTRIB.VAR_TYPE = cell(0,1);       % valid values: 'data', 'support_data', 'metadata' and 'ignore_data'.
    % Others, used in source CDF files from UNH
    VATTRIB.MONOTON = cell(0,1); % For time variables valid values: 'INCREASE' and 'DECREASE', can speed up reading of cdf file.
  end

end
