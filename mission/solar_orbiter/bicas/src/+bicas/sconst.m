%
% Hard-coded constants representing signal IDs and routings: ASID, SSID, SDID,
% and rountings generated by code.
%
%
% IMPLEMENTATION NOTE: ASIDs, SSIDs, SDIDs are implemented as uint8 values for
% performance reasons. The implementation uses values per channel and CDF
% record which is too many instances for implementing them as objects, though
% that would make the code simpler and more natural. This class supplies
% functions which correspond to the methods of such classes. The classes ASID,
% SSID, SDID (bicas.proc.L1L2.AntennaSignalId, bicas.proc.L1L2.SignalSourceId,
% bicas.proc.L1L2.SignalDestinationId) are only for defining metadata
% associated with each uint8 value and to make the implementation of above
% mentioned method-replacing functions easier.
%
%
% Author: Erik P G Johansson, IRF, Uppsala, Sweden
%
classdef sconst
% PROPOSAL: Move to bicas.proc.L1L2.*.
%   PROPOSAL: bicas.proc.L1L2.const
%
% NOTE: Feels like there should be a better way of implementing ASID, SSID,
%       SDIDs as uint8 + functions, but not sure how.
%
% PROPOSAL: Keep ASID, SSID, SDID as uint8 but also keep corresponding objects,
%           but defer functions on uint8 to object methods via dictionaries
%           uint8-->object. -- IMPLEMENTED
%   Ex: C.SSID_OBJ_DICT(ssid).is_ASR()
%   PRO: More natural way of hardcoding information about each uint8 value.
%   CON: Akward to have two versions of ASID,SSID,SDID at the same time.
%     PRO: Separate names/abbreviations. 3-->2x3
%     CON: Use same abbreviations for both uint8 and objects.
%   CON: Still long calls.
%
%
% PROPOSAL: Hardcode information in structs (or objects) in private
%           dictionaries which bicas.sconst function implementations then use.
%   PRO: Automatic checks on uint8 (type), integer range (dictionary keys).
%   PRO: Does not need rely on adding/subtracting to translate between
%        ASID, SSID, SDID.
%
% PROPOSAL: Separate class constants for ASID, SSID, SDID respectively.
%   Replace .C --> .ASID (asid?), .SSID (ssid?) etc.
%   CON: Bad if wanting to "import" all constants at once.
%
% PROPOSAL: Rename ASID, SSID, SDID objects.
%   ~definition
%   ~info, ~data, metadata
%   --
%   SignalSourceDefinition
%   SignalSourceIdDefinition
%   SignalSourceIdInfo



  %###########
  %###########
  % CONSTANTS
  %###########
  %###########
  properties(Constant)



    C = bicas.sconst.init_const();



  end    % properties(Constant)



  %#######################
  %#######################
  % PUBLIC STATIC METHODS
  %#######################
  %#######################
  methods(Static, Access=public)



    % Define all constants for ASID, SSID, SDID, and Routing.
    %
    % IMPLEMENTATION NOTE: Defining one constant struct, which contains
    % multiple constants as fields. Makes it possible to access constants
    % through a variable copy of this constant rather than using the long
    % qualifiers.
    %
    % NOTE: Construction is problematic since bicas.proc.L1L2.Routing
    % constructors can not use other fields in bicas.sconst.C for assertions,
    % since it has not been initialized at that time. Also, bad syntax in this
    % code tends to give strange unintuitive error messages and error behaviour
    % in MATLAB.
    %
    % NOTE:
    function C2 = init_const()
      C2 = struct();

      C2.ASID_DICT     = configureDictionary('string', 'uint8');
      C2.ASID_OBJ_DICT = configureDictionary('uint8',  'bicas.proc.L1L2.AntennaSignalId');

      C2.SSID_DICT     = configureDictionary('string', 'uint8');
      C2.SSID_OBJ_DICT = configureDictionary('uint8',  'bicas.proc.L1L2.SignalSourceId');

      C2.SDID_DICT     = configureDictionary('string', 'uint8');
      C2.SDID_OBJ_DICT = configureDictionary('uint8',  'bicas.proc.L1L2.SignalDestinationId');

      C2.ROUTING_DICT  = configureDictionary('string', 'bicas.proc.L1L2.Routing');

      % Global list of uint8 values used so far for defining ASIDs, SSIDs, and
      % SDIS. For avoiding collisions between all of them combined, not just
      % within each category (for safety).
      kSet = [];

      function assert_new_uint8(k)
        assert(isnumeric(k))
        assert(~ismember(k, kSet))
        kSet(end+1) = k;
      end

      function add_ASR(s, k, asidCategory, asidAntennas)
        asid = uint8(k);

        ssid = add_SSID(s, k, asid);
        sdid = add_SDID(s, k, asid);

        AsidObj                = bicas.proc.L1L2.AntennaSignalId(ssid, asidCategory, asidAntennas);
        C2.ASID_DICT(s)        = asid;
        C2.ASID_OBJ_DICT(asid) = AsidObj;

        C2.ROUTING_DICT(s)     = bicas.proc.L1L2.Routing(ssid, sdid);
      end

      function ssid = add_SSID(s, k, asidOrSpecialCase)
        ssid = uint8(k+100);
        assert_new_uint8(ssid)

        SsidObj = bicas.proc.L1L2.SignalSourceId(asidOrSpecialCase);
        C2.SSID_DICT(s)        = ssid;
        C2.SSID_OBJ_DICT(ssid) = SsidObj;
      end

      function sdid = add_SDID(s, k, asidOrNowhere)
        sdid = uint8(k+200);
        assert_new_uint8(sdid)

        SdidObj = bicas.proc.L1L2.SignalDestinationId(asidOrNowhere);
        C2.SDID_DICT(s)        = sdid;
        C2.SDID_OBJ_DICT(sdid) = SdidObj;
      end

      function main()
        % =====================================
        % Add every possible unique ASID object
        % =====================================
        add_ASR("DC_V1",  1, "DC_SINGLE", [1   ]);
        add_ASR("DC_V2",  2, "DC_SINGLE", [2   ]);
        add_ASR("DC_V3",  3, "DC_SINGLE", [3   ]);

        add_ASR("DC_V12", 4, "DC_DIFF",   [1, 2]);
        add_ASR("DC_V13", 5, "DC_DIFF",   [1, 3]);
        add_ASR("DC_V23", 6, "DC_DIFF",   [2, 3]);

        add_ASR("AC_V12", 7, "AC_DIFF",   [1, 2]);
        add_ASR("AC_V13", 8, "AC_DIFF",   [1, 3]);
        add_ASR("AC_V23", 9, "AC_DIFF",   [2, 3]);

        add_SSID("REF25V",  10, "REF25V");
        add_SSID("GND",     11, "GND");
        add_SSID("UNKNOWN", 12, "UNKNOWN");

        add_SDID("NOWHERE", 13, "NOWHERE");

        C2.ROUTING_DICT("REF25V_TO_DC_V1")    = bicas.proc.L1L2.Routing(C2.SSID_DICT("REF25V"),  C2.SDID_DICT("DC_V1"));
        C2.ROUTING_DICT("REF25V_TO_DC_V2")    = bicas.proc.L1L2.Routing(C2.SSID_DICT("REF25V"),  C2.SDID_DICT("DC_V2"));
        C2.ROUTING_DICT("REF25V_TO_DC_V3")    = bicas.proc.L1L2.Routing(C2.SSID_DICT("REF25V"),  C2.SDID_DICT("DC_V3"));
        C2.ROUTING_DICT("GND_TO_DC_V1")       = bicas.proc.L1L2.Routing(C2.SSID_DICT("GND"),     C2.SDID_DICT("DC_V1"));
        C2.ROUTING_DICT("GND_TO_DC_V2")       = bicas.proc.L1L2.Routing(C2.SSID_DICT("GND"),     C2.SDID_DICT("DC_V2"));
        C2.ROUTING_DICT("GND_TO_DC_V3")       = bicas.proc.L1L2.Routing(C2.SSID_DICT("GND"),     C2.SDID_DICT("DC_V3"));
        C2.ROUTING_DICT("UNKNOWN_TO_NOWHERE") = bicas.proc.L1L2.Routing(C2.SSID_DICT("UNKNOWN"), C2.SDID_DICT("NOWHERE"));

        assert(~ismember(0,   kSet))
        assert(~ismember(255, kSet))
      end

      main()
    end



    %======
    % ASID
    %======
    function isAsid = is_ASID(asidAr)
      assert(isa(asidAr, "uint8"))
      isAsid = all(ismember(asidAr, bicas.sconst.C.ASID_DICT.values), "ALL");
    end

    function asidCategory = get_ASID_category(asid)
      assert(isscalar(asid))
      asidCategory = bicas.sconst.C.ASID_OBJ_DICT(asid).category;
    end

    function antennas = get_ASID_antennas(asid)
      assert(isscalar(asid))
      antennas = bicas.sconst.C.ASID_OBJ_DICT(asid).antennas;
    end

    function ssid = ASID_to_SSID(asid)
      assert(isscalar(asid))
      ssid = bicas.sconst.C.ASID_OBJ_DICT(asid).ssid;
    end



    %======
    % SSID
    %======
    function isSsid = is_SSID(ssidAr)
      assert(isa(ssidAr, "uint8"))
      isSsid = all(ismember(ssidAr, bicas.sconst.C.SSID_DICT.values), "ALL");
    end

    function isAsr = SSID_is_ASR(ssid)
      assert(isscalar(ssid))
      isAsr = bicas.sconst.C.SSID_OBJ_DICT(ssid).is_ASR();
    end

    % NOTE: Error if not ASR.
    function asid = SSID_ASR_to_ASID(ssid)
      assert(bicas.sconst.is_SSID(ssid) & isscalar(ssid))
      assert(bicas.sconst.SSID_is_ASR(ssid))

      asid = bicas.sconst.C.SSID_OBJ_DICT(ssid).asid;
      assert(bicas.sconst.is_ASID(asid))
    end

    function isAc = SSID_is_AC(ssid)
      assert(isscalar(ssid))

      if bicas.sconst.SSID_is_ASR(ssid)
        asid = bicas.sconst.SSID_ASR_to_ASID(ssid);
        isAc = (bicas.sconst.get_ASID_category(asid) == "AC_DIFF");
      else
        isAc = false;
      end
    end

    function isDiff = SSID_is_diff(ssid)
      assert(bicas.sconst.is_SSID(ssid) & isscalar(ssid))

      if bicas.sconst.SSID_is_ASR(ssid)
        asid = bicas.sconst.SSID_ASR_to_ASID(ssid);
        isDiff = ismember(bicas.sconst.get_ASID_category(asid), ["DC_DIFF", "AC_DIFF"]);
      else
        isDiff = false;
      end
    end



    %======
    % SDID
    %======
    function isSsid = is_SDID(sdidAr)
      assert(isa(sdidAr, "uint8"))
      isSsid = all(ismember(sdidAr, bicas.sconst.C.SDID_DICT.values), "ALL");
    end

    function isAsr = SDID_is_ASR(sdid)
      assert(isscalar(sdid))
      isAsr = bicas.sconst.C.SDID_OBJ_DICT(sdid).is_ASR();
    end

    % NOTE: Error if not ASR.
    function asid = SDID_ASR_to_ASID(sdid)
      assert(isscalar(sdid))
      assert(bicas.sconst.SDID_is_ASR(sdid))

      asid = bicas.sconst.C.SDID_OBJ_DICT(sdid).asid;
    end

    function isNowhere = SDID_is_nowhere(sdid)
      assert(bicas.sconst.is_SDID(sdid) & isscalar(sdid))
      isNowhere = (sdid == bicas.sconst.C.SDID_DICT("NOWHERE"));
    end



  end    % methods(Static, Access=public)



end
